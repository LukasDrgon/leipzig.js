<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Leipzig.js: Documentation</title>
  <link rel="stylesheet" href="/leipzig.js/theme/css/normalize.min.css">
  <link rel="stylesheet" href="/leipzig.js/theme/css/pygments.css">
  <link rel="stylesheet" href="/leipzig.js/theme/css/site.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/leipzig/latest/leipzig.min.css">
</head>
<body>
  <div id="wrapper">
    <header id="masthead">
      <h1 class="page-title">Leipzig.js</h1>
      <h2 class="tagline">Interlinear glossing for the browser</h2>
      <nav id="main-nav">
        <ul><li><a href="/leipzig.js/">Home</a></li><li><a href="/leipzig.js/examples">Examples</a></li><li><a href="/leipzig.js/demo">Demo</a></li><li class="active"><a href="/leipzig.js/documentation">Documentation</a></li><li><a href="https://github.com/bdchauvette/leipzig.js/">Code</a></li>
        </ul>
      </nav>
    </header>


  <h1>Marking Up Examples</h1>
<p>Leipzig.js is flexible when it comes to what underlying tags you use to mark up
your glosses. For semantic reasons, I like to use <code>&lt;p&gt;</code> tags in a <code>&lt;div&gt;</code>, e.g.</p>
<div class="highlight"><pre><span class="nt">&lt;div</span> <span class="na">data-gloss</span><span class="nt">&gt;</span>
  <span class="nt">&lt;p&gt;</span>ein Beispiel<span class="nt">&lt;/p&gt;</span>
  <span class="nt">&lt;p&gt;</span>DET.NOM.N.SG example<span class="nt">&lt;/p&gt;</span>
  <span class="nt">&lt;p&gt;&lt;/p&gt;</span>
  <span class="nt">&lt;p&gt;</span>‘an example’<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</pre></div>


<div class="gloss--markup example" data-gloss>
  <p>ein Beispiel</p>
  <p>DET.NOM.N.SG example</p>
  <p>‘an example’</p>
</div>

<p>You can also mark it up as a list, and Leipzig.js will add the aligned words as
an <code>&lt;li&gt;</code> item:</p>
<div class="highlight"><pre><span class="nt">&lt;ul</span> <span class="na">data-gloss</span><span class="nt">&gt;</span>
  <span class="nt">&lt;li&gt;</span>ein Beispiel<span class="nt">&lt;/li&gt;</span>
  <span class="nt">&lt;li&gt;</span>DET.NOM.N.SG example<span class="nt">&lt;/li&gt;</span>
  <span class="nt">&lt;li&gt;&lt;/li&gt;</span>
  <span class="nt">&lt;li&gt;</span>‘an example’<span class="nt">&lt;/li&gt;</span>
<span class="nt">&lt;/ul&gt;</span>
</pre></div>


<ul class="gloss--markup example" data-gloss>
  <li>ein Beispiel</li>
  <li>DET.NOM.N.SG example</li>
  <li>‘an example’</li>
</ul>

<p>To make the parser treat multiple words as a single unit, surround the words
with curly braces, e.g.:</p>
<div class="highlight"><pre><span class="nt">&lt;div</span> <span class="na">data-gloss</span><span class="nt">&gt;</span>
  <span class="nt">&lt;p&gt;</span>El perrito está comiendo.<span class="nt">&lt;/p&gt;</span>
  <span class="nt">&lt;p&gt;</span>the {little dog} is eating.<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</pre></div>


<div id="gloss--grouping" class="example">
  <p>El perrito está comiendo.</p>
  <p>the {little dog} is eating.</p>
</div>

<hr />
<h1><code>Leipzig()</code></h1>
<div class="highlight"><pre><span class="nx">Leipzig</span><span class="p">([</span><span class="nx">selector</span> <span class="o">:</span> <span class="nb">String</span><span class="o">|</span><span class="nx">NodeList</span><span class="o">|</span><span class="nx">Element</span><span class="p">],</span> <span class="p">[</span><span class="nx">config</span> <span class="o">:</span> <span class="nb">Object</span><span class="p">]</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">Function</span>
</pre></div>


<p>Leipzig.js takes two optional arguments during construction:</p>
<ol>
<li><code>selector</code>, which tells Leipzig.js which elements to gloss</li>
<li><code>config</code>, a plain JavaScript object for configuration</li>
</ol>
<p>Neither argument is required when creating a new Leipzig.js object, and if no
arguments are provided, then Leipzig.js will use the default configuration,
listed below.</p>
<h2>Defaults</h2>
<p>Leipzig.js defaults to a three-line glossing pattern, where the first two lines
are word-aligned, and the last line is a non-aligned free translation.</p>
<p>The default configuraiton is the following:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">leipzig</span> <span class="o">=</span> <span class="nx">Leipzig</span><span class="p">({</span>
  <span class="nx">selector</span><span class="o">:</span> <span class="s1">&#39;[data-gloss]&#39;</span><span class="p">,</span>
  <span class="nx">lastLineFree</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="nx">firstLineOrig</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="nx">spacing</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="nx">autoTag</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="nx">async</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="nx">lexers</span><span class="o">:</span> <span class="p">[</span>
    <span class="s1">&#39;{(.*?)}&#39;</span><span class="p">,</span>
    <span class="s1">&#39;([^\\s]+)&#39;</span>
  <span class="p">],</span>
  <span class="nx">events</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">beforeGloss</span><span class="o">:</span> <span class="s1">&#39;gloss:beforeGloss&#39;</span><span class="p">,</span>
    <span class="nx">afterGloss</span><span class="o">:</span> <span class="s1">&#39;gloss:afterGloss&#39;</span><span class="p">,</span>
    <span class="nx">beforeLex</span><span class="o">:</span> <span class="s1">&#39;gloss:beforeLex&#39;</span><span class="p">,</span>
    <span class="nx">afterLex</span><span class="o">:</span> <span class="s1">&#39;gloss:afterLex&#39;</span><span class="p">,</span>
    <span class="nx">beforeAlign</span><span class="o">:</span> <span class="s1">&#39;gloss:beforeAlign&#39;</span><span class="p">,</span>
    <span class="nx">afterAlign</span><span class="o">:</span><span class="s1">&#39;gloss:afterAlign&#39;</span><span class="p">,</span>
    <span class="nx">beforeFormat</span><span class="o">:</span> <span class="s1">&#39;gloss:beforeFormat&#39;</span><span class="p">,</span>
    <span class="nx">afterFormat</span><span class="o">:</span><span class="s1">&#39;gloss:afterFormat&#39;</span><span class="p">,</span>
    <span class="nx">start</span><span class="o">:</span> <span class="s1">&#39;gloss:start&#39;</span><span class="p">,</span>
    <span class="nx">complete</span><span class="o">:</span> <span class="s1">&#39;gloss:complete&#39;</span>
  <span class="p">},</span>
  <span class="nx">classes</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">glossed</span><span class="o">:</span> <span class="s1">&#39;gloss--glossed&#39;</span><span class="p">,</span>
    <span class="nx">noSpace</span><span class="o">:</span> <span class="s1">&#39;gloss--no-space&#39;</span><span class="p">,</span>
    <span class="nx">words</span><span class="o">:</span> <span class="s1">&#39;gloss__words&#39;</span><span class="p">,</span>
    <span class="nx">word</span><span class="o">:</span> <span class="s1">&#39;gloss__word&#39;</span><span class="p">,</span>
    <span class="nx">line</span><span class="o">:</span> <span class="s1">&#39;gloss__line--&#39;</span><span class="p">,</span>
    <span class="nx">original</span><span class="o">:</span> <span class="s1">&#39;gloss__line--original&#39;</span><span class="p">,</span>
    <span class="nx">freeTranslation</span><span class="o">:</span> <span class="s1">&#39;gloss__line--free&#39;</span><span class="p">,</span>
    <span class="nx">noAlign</span><span class="o">:</span> <span class="s1">&#39;gloss__line--no-align&#39;</span><span class="p">,</span>
    <span class="nx">hidden</span><span class="o">:</span> <span class="s1">&#39;gloss__line--hidden&#39;</span><span class="p">,</span>
    <span class="nx">abbr</span><span class="o">:</span> <span class="s1">&#39;gloss__abbr&#39;</span>
  <span class="p">},</span>
  <span class="nx">abbreviations</span><span class="o">:</span> <span class="p">{...}</span> <span class="c1">// See Leipzig.abbreviations section</span>
<span class="p">});</span>
</pre></div>


<p>When configuring Leipzig.js, you only need to specify the options that you want
to change. All other options will retain their default values.</p>
<h2><code>selector: String | NodeList | Element</code></h2>
<div class="highlight"><pre><span class="c1">// default: &#39;[data-gloss]&#39;</span>
</pre></div>


<p>This option configures which elements that the Leipzig.js glosser will operate
on. You can set this option by either passing it as the first argument when
initializing Leipzig.js, or by setting the <code>selector</code> argument in the
configuration object:</p>
<div class="highlight"><pre><span class="c1">// Two ways of saying the same thing</span>
<span class="kd">var</span> <span class="nx">leipzig</span> <span class="o">=</span> <span class="nx">Leipzig</span><span class="p">(</span><span class="s1">&#39;[data-gloss]&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">leipzig</span> <span class="o">=</span> <span class="nx">Leipzig</span><span class="p">({</span> <span class="nx">selector</span><span class="o">:</span> <span class="s1">&#39;[data-gloss]&#39;</span> <span class="p">});</span>
</pre></div>


<p>The elements option can be a <code>String</code>, a <code>NodeList</code> or <code>Element</code>.</p>
<p>If the <code>selector</code> argument is a <code>String</code>, Leipzig.js will internally run
<code>document.querySelectorAll()</code> using the specified string, and the glosser will
operate on the list of <abbr>DOM</abbr> elements it returns.</p>
<p>Likewise, if <code>selector</code> is an <code>Element</code> or a <code>NodeList</code>, the glosser will
operate on the provided <abbr>DOM</abbr> element(s).</p>
<h2><code>lastLineFree : Boolean</code></h2>
<div class="highlight"><pre><span class="c1">// default: true</span>
</pre></div>


<p>Leipzig.js can automatically mark the last line in a gloss as a free
translation, which will add a special class to it (<code>.gloss__line--free</code> by
default) and make it not be parsed for alignment.</p>
<div id="gloss--first-line" class="example">
  <p>El perr-ito está comiendo.</p>
  <p>DET.M.SG dog-DIM be.3SG.PRS eat.PTCP</p>
  <p>‘The little dog is eating.’</p>
</div>

<p>This behavior is controlled by the <code>lastLineFree</code> configuration option, and is
<em>enabled</em> by default.</p>
<p>To disable automatically parsing the last line as a free translation, set
<code>lastLineFree</code> to <code>false</code> when initializing Leipzig.js:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">leipzig</span> <span class="o">=</span> <span class="nx">Leipzig</span><span class="p">({</span> <span class="nx">lastLineFree</span><span class="o">:</span> <span class="kc">false</span> <span class="p">});</span>
</pre></div>


<p>If you turn this option off, you can still mark a line as a free translation by
adding the free translation <abbr>CSS</abbr> class (<code>gloss__line--free</code> by
default) to the underlying <abbr>HTML</abbr>:</p>
<div class="highlight"><pre><span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">&quot;gloss__line--free&quot;</span><span class="nt">&gt;</span>‘The little dog is eating.’<span class="nt">&lt;/p&gt;</span>
</pre></div>


<h2><code>firstLineOrig : Boolean</code></h2>
<div class="highlight"><pre><span class="c1">// default: false</span>
</pre></div>


<p>Leipzig.js can also automatically mark the first line in the gloss
as the <em>original language line</em>, which will add a special class to it
(<code>.gloss__line--original</code> by default) and make it not be parsed for alignment.</p>
<p>This behavior is useful in cases where the line being glossed is long, or if
the original language is not usually written with spaces, e.g. Japanese:</p>
<div id="gloss--orig-line" class="example">
  <p>太陽が昇る。</p>
  <p>太陽 が 昇る。</p>
  <p>taiyō ga noboru</p>
  <p>sun NTOP rise</p>
</div>

<p>This behavior is controlled by the <code>firstLineOrig</code> configuration option, and is
<em>disabled</em> by default.</p>
<p>To enable automatically parsing the first line as original text, set
<code>firstLineOrig</code> to <code>true</code> when initializing Leipzig.js:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">leipzig</span> <span class="o">=</span> <span class="nx">Leipzig</span><span class="p">({</span> <span class="nx">firstLineOrig</span><span class="o">:</span> <span class="kc">true</span> <span class="p">});</span>
</pre></div>


<p>If <code>firstLineOrig</code> is disabled, you can still mark a line as a original text
by adding the original text <abbr>CSS</abbr> class (<code>gloss__line--original</code> by
default) to the underlying <abbr>HTML</abbr>:</p>
<div class="highlight"><pre><span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">&quot;gloss__line--original&quot;</span><span class="nt">&gt;</span>太陽が昇る。<span class="nt">&lt;/p&gt;</span>
</pre></div>


<h2><code>spacing : Boolean</code></h2>
<div class="highlight"><pre><span class="c1">// default: true</span>
</pre></div>


<p>The default Leipzig.js styling includes small horizontal spacing at glossed
word boundaries. For highly agglutinative languages, this behavior may not be
ideal, because glossed phrases are likely to contain many morphemes in one
word:</p>
<p>To remove this automatic spacing, you can set the <code>spacing</code> option to <code>false</code>
when initializing Leipzig.js:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">leipzig</span> <span class="o">=</span> <span class="nx">Leipzig</span><span class="p">({</span> <span class="nx">spacing</span><span class="o">:</span> <span class="kc">false</span> <span class="p">});</span>
</pre></div>


<p>This will add an additional class to the gloss container (<code>.gloss--no-space</code> by
default), which removes the horizontal space.</p>
<h2><code>autoTag : Boolean</code></h2>
<div class="highlight"><pre><span class="c1">// default: true</span>
</pre></div>


<p>By default, Leipzig.js will try to wrap morphemic glosses in <code>&lt;abbr&gt;</code> tags.
Beginning with the <em>second</em> line of the aligned lines, the parser looks
for the following types of morphemes to tag:</p>
<ol>
<li>Numbers 1 through 4, corresponding to possible person morphemes;</li>
<li>Sequences of &geq;1 uppercase letters, e.g. N, SG, or PST.</li>
</ol>
<p>The parser attempts to assign a <code>title</code> attribute to any matches by looking for
a matching key in the <code>Leipzig.abbreviations</code> object. This object contains
key-value pairs based on the <a href="https://www.eva.mpg.de/lingua/resources/glossing-rules.php">standard abbreviations of the Leipzig Glossing
Rules</a>.</p>
<p>You can customize the definitions by adding or modifiying the keys and values
on the <code>Leipzig.abbreviations</code> object. For example, the following code changes
the definition of <code>COMP</code> from <code>complementizer</code> to <code>comparative</code>:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">leipzig</span> <span class="o">=</span> <span class="nx">Leipzig</span><span class="p">();</span>
<span class="nx">leipzig</span><span class="p">.</span><span class="nx">abbreviations</span><span class="p">.</span><span class="nx">COMP</span> <span class="o">=</span> <span class="s1">&#39;comparative&#39;</span><span class="p">;</span>
</pre></div>


<h2><code>async : Boolean</code></h2>
<div class="highlight"><pre><span class="c1">// default: false</span>
</pre></div>


<p>Leipzig.js runs synchronously by default, and normally this is fine. However,
when running synchronously, the browser will wait for Leipzig.js to finish
before attending to the needs of other scripts and browser events. This means
that if you have a large number of glosses on a page, the user experience might
start to suffer.</p>
<p>To remedy this, you can set the <code>async</code> option to <code>true</code>, which will cause
Leipzig.js to run (somewhat) asynchronously.</p>
<p>You can use the optional callback to <code>Leipzig#gloss()</code> to perform actions when
the glossing has been completed.</p>
<h2><code>abbreviations : Object</code></h2>
<p>If you pass in a plain JS object, it will override <a href="#default-definitions">the default
auto-tagging definitions</a>.</p>
<h2><code>lexers : Array&lt;String&gt; | String | RegExp</code></h2>
<div class="highlight"><pre><span class="c1">// default: [&#39;{(.*?)}&#39;, &#39;([^\\s]+)&#39;]</span>
</pre></div>


<p>This option controls how Leipzig breaks lines into aligned words.</p>
<p>If passed a <code>String</code> or an <code>Array</code> of <code>String</code>s, Leipzig will convert them into
a <code>RegExp</code> object used for lexing the lines. The following configurations
produce the same lexer:</p>
<div class="highlight"><pre><span class="c1">// Array&lt;String&gt;</span>
<span class="kd">var</span> <span class="nx">leipzig</span> <span class="o">=</span> <span class="nx">Leipzig</span><span class="p">({</span> <span class="nx">lexers</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;{(.*?)}&#39;</span><span class="p">,</span> <span class="s1">&#39;([^\\s]+)&#39;</span><span class="p">]</span> <span class="p">});</span>

<span class="c1">// String</span>
<span class="kd">var</span> <span class="nx">leipzig</span> <span class="o">=</span> <span class="nx">Leipzig</span><span class="p">({</span> <span class="nx">lexers</span><span class="o">:</span> <span class="s1">&#39;{(.*?)}|([^\\s]+)&#39;</span> <span class="p">});</span>

<span class="c1">// RegExp</span>
<span class="kd">var</span> <span class="nx">leipzig</span> <span class="o">=</span> <span class="nx">Leipzig</span><span class="p">({</span> <span class="nx">lexers</span><span class="o">:</span> <span class="sr">/{(.*?)}|([^\s]+)/g</span> <span class="p">});</span>
</pre></div>


<h2><code>events : Object</code></h2>
<p>Leipzig.js triggers certain events during the glossing process. You can act on
these events by creating an event listener before calling the glosser:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">leipzig</span> <span class="o">=</span> <span class="nx">Leipzig</span><span class="p">();</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;gloss:onComplete&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Glossing complete!&#39;</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">leipzig</span><span class="p">.</span><span class="nx">gloss</span><span class="p">();</span>

<span class="c1">// -&gt; Glossing complete!</span>
</pre></div>


<p>Following the DOM Custom Event API, some of the events have <code>detail</code> objects,
which contain additional information about the event. For events without detail
objects, you should be able to access all relevant information from various
methods on <code>event.target</code>.</p>
<p>The default event names are listed in the table below, along with additional
information about each event.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Triggers...</th>
<th>Details Object</th>
</tr>
</thead>
<tbody>
<tr>
<td>gloss:start</td>
<td>Before glossing any <code>Element</code></td>
<td><code>{ glosses: NodeList }</code></td>
</tr>
<tr>
<td>gloss:complete</td>
<td>After glossing every <code>Element</code></td>
<td><code>{ glosses: NodeList }</code></td>
</tr>
<tr>
<td>gloss:beforeGloss</td>
<td>Before each <code>Element</code> is glossed</td>
<td>--</td>
</tr>
<tr>
<td>gloss:afterGloss</td>
<td>After each <code>Element</code> is glossed</td>
<td>--</td>
</tr>
<tr>
<td>gloss:beforeLex</td>
<td>Before lexing each line</td>
<td>--</td>
</tr>
<tr>
<td>gloss:afterLex</td>
<td>After lexing each line</td>
<td><code>{ tokens: Array&lt;String&gt; }</code></td>
</tr>
<tr>
<td>gloss:beforeAlign</td>
<td>Before aligning lexed lines</td>
<td><code>{ lines: Array&lt;Array&lt;String&gt;&gt; }</code></td>
</tr>
<tr>
<td>gloss:afterAlign</td>
<td>After aligning lexed line</td>
<td><code>{ lines: Array&lt;Array&lt;String&gt;&gt; }</code></td>
</tr>
<tr>
<td>gloss:beforeFormat</td>
<td>Before formatting aligned lines</td>
<td><code>{ lines: Array&lt;Array&lt;String&gt;&gt; }</code></td>
</tr>
<tr>
<td>gloss:afterFormat</td>
<td>After formatting aligned lines</td>
<td>--</td>
</tr>
</tbody>
</table>
<p>You can customize the event names by passing a plain JavaScript object to the
<code>events</code> key on your <code>config</code> object, e.g.:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">leipzig</span> <span class="o">=</span> <span class="nx">Leipzig</span><span class="p">({</span>
  <span class="nx">events</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">complete</span><span class="o">:</span> <span class="s1">&#39;newOnComplete&#39;</span>
  <span class="p">}</span>
<span class="p">});</span>
</pre></div>


<h2><code>classes : Object</code></h2>
<p>Leipzig.js adds a number of <abbr>CSS</abbr> classes to the final gloss, which
you can use to style your glosses. The names of these classes can be configured
by changing the the settings on the <code>class</code> object within the <code>options</code>
configuration object.</p>
<p>The names, meaning, and default values of the classes are as follows:</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>glossed</code></td>
<td><code>gloss--glossed</code></td>
<td>Added to each element in <code>selector</code> after the glosser has finished</td>
</tr>
<tr>
<td><code>noSpace</code></td>
<td><code>gloss--no-space</code></td>
<td>Added to each element in <code>selector</code> when the <code>spacing</code> option is set to false</td>
</tr>
<tr>
<td><code>words</code></td>
<td><code>gloss__words</code></td>
<td>Added to the group of words that are aligned</td>
</tr>
<tr>
<td><code>word</code></td>
<td><code>gloss__word</code></td>
<td>Added to each word in the group of aligned words</td>
</tr>
<tr>
<td><code>line</code></td>
<td><code>gloss__line</code></td>
<td>Added to each visible line in the gloss</td>
</tr>
<tr>
<td><code>lineNum</code></td>
<td><code>gloss__line--#</code></td>
<td>Added to each visible line in the gloss. The number at the end is a zero-indexed index of the line in the gloss, and can be used to style individual lines</td>
</tr>
<tr>
<td><code>freeTranslation</code></td>
<td><code>gloss__line--free</code></td>
<td>The free translation line</td>
</tr>
<tr>
<td><code>original</code></td>
<td><code>gloss__line--original</code></td>
<td>The original language line</td>
</tr>
<tr>
<td><code>noAlign</code></td>
<td><code>gloss__line--no-align</code></td>
<td>Can be manually added to tell the parser to skip a line when aligning words</td>
</tr>
<tr>
<td><code>abbr</code></td>
<td><code>gloss__abbr</code></td>
<td>Added to morpheme abbreviations by the auto-tagger</td>
</tr>
</tbody>
</table>
<p>The following example shows the class structure of what a gloss looks like after
being fully parsed and formatted:</p>
<div id="gloss--style" class="example gloss--glossed">
  <p>Nikukonda</p>
  <p>Ni- ku- kond -a</p>
  <p>1SG.SBJ- 2SG.OBJ- love -IND</p>
  <p class="gloss__line--free">‘I love you’</p>
  <p class="gloss__line--no-align">Town Nyanja (Lusaka, Zambia)</p>
</div>

<div class="highlight"><pre><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;gloss--style&quot;</span> <span class="na">class=</span><span class="s">&quot;example gloss--no-space gloss--glossed&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">&quot;gloss__line gloss__line--0 gloss__line--original&quot;</span><span class="nt">&gt;</span>Nikukonda<span class="nt">&lt;/p&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;gloss__words&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;gloss__word&quot;</span><span class="nt">&gt;</span>
      <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">&quot;gloss__line gloss__line--1&quot;</span><span class="nt">&gt;</span>Ni-<span class="nt">&lt;/p&gt;</span>
      <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">&quot;gloss__line gloss__line--2&quot;</span><span class="nt">&gt;</span>1SG.SBJ-<span class="nt">&lt;/p&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;gloss__word&quot;</span><span class="nt">&gt;</span>
      <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">&quot;gloss__line gloss__line--1&quot;</span><span class="nt">&gt;</span>ku-<span class="nt">&lt;/p&gt;</span>
      <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">&quot;gloss__line gloss__line--2&quot;</span><span class="nt">&gt;</span>2SG.OBJ-<span class="nt">&lt;/p&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;gloss__word&quot;</span><span class="nt">&gt;</span>
      <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">&quot;gloss__line gloss__line--1&quot;</span><span class="nt">&gt;</span>kond<span class="nt">&lt;/p&gt;</span>
      <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">&quot;gloss__line gloss__line--2&quot;</span><span class="nt">&gt;</span>love<span class="nt">&lt;/p&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;gloss__word&quot;</span><span class="nt">&gt;</span>
      <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">&quot;gloss__line gloss__line--1&quot;</span><span class="nt">&gt;</span>-a<span class="nt">&lt;/p&gt;</span>
      <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">&quot;gloss__line gloss__line--2&quot;</span><span class="nt">&gt;</span>-IND<span class="nt">&lt;/p&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
  <span class="nt">&lt;/div&gt;</span>
  <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">&quot;gloss__line--hidden&quot;</span><span class="nt">&gt;</span>Ni- ku- kond -a<span class="nt">&lt;/p&gt;</span>
  <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">&quot;gloss__line--hidden&quot;</span><span class="nt">&gt;</span>1SG.SBJ- 2SG.OBJ- love -IND<span class="nt">&lt;/p&gt;</span>
  <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">&quot;gloss__line gloss__line--3 gloss__line--free&quot;</span><span class="nt">&gt;</span>‘I love you’<span class="nt">&lt;/p&gt;</span>
  <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">&quot;gloss__line gloss__line--4 gloss__line--no-align&quot;</span><span class="nt">&gt;</span>Town Nyanja (Lusaka, Zambia)<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</pre></div>


<p>If the class names of the last three options &ndash; <code>classes.freeTranslation</code>,
<code>classes.original</code>, and <code>classes.noAlign</code> &ndash; are manually added to the html
markup, they will be skipped by the Leipzig.js glosser during parsing, and will
not be word-aligned with the other text.</p>
<p><strong><abbr>NB:</abbr></strong> If a line is manually skipped by adding the
<code>classes.noAlign</code> class, it might interfere with the automated Free Translation and
Original Language line detection. If this happens, you will have to manually
add the relevant classes to the underlying markup.</p>
<hr />
<h1><code>Leipzig#config()</code></h1>
<div class="highlight"><pre><span class="nx">Leipzig</span><span class="p">.</span><span class="nx">config</span><span class="p">(</span><span class="nx">config</span> <span class="o">:</span> <span class="nb">Object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">Void</span>
</pre></div>


<p>This option allows you to configure Leipzig.js after initializing it. The
following code snippets have the same effect:</p>
<div class="highlight"><pre><span class="c1">// Setting config during initialization</span>
<span class="kd">var</span> <span class="nx">leipzig</span> <span class="o">=</span> <span class="nx">Leipzig</span><span class="p">({</span> <span class="nx">async</span><span class="o">:</span> <span class="kc">true</span> <span class="p">});</span>

<span class="c1">// Setting config via Leipzig#config()</span>
<span class="kd">var</span> <span class="nx">leipzig</span> <span class="o">=</span> <span class="nx">Leipzig</span><span class="p">();</span>
<span class="nx">leipzig</span><span class="p">.</span><span class="nx">config</span><span class="p">({</span> <span class="nx">async</span><span class="o">:</span> <span class="kc">true</span> <span class="p">});</span>
</pre></div>


<p><strong><abbr>NB:</abbr></strong> The <code>config</code> method will only set the options
passed in via the configuration object. All other settings will return to their
default values.</p>
<hr />
<h1><code>Leipzig#gloss()</code></h1>
<div class="highlight"><pre><span class="nx">Leipzig</span><span class="p">.</span><span class="nx">gloss</span><span class="p">([</span><span class="nx">callback</span> <span class="o">:</span> <span class="nb">Function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">elements</span><span class="p">)])</span> <span class="o">-&gt;</span> <span class="nx">Void</span>
</pre></div>


<p>This method runs the glosser over the elements that were specified when
initializing the Leipzig object.</p>
<p>It accepts an optional, error-first style callback function that will be called
once all of the glosses have been completed (or the glosser encounters an
error):</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">leipzig</span> <span class="o">=</span> <span class="nx">Leipzig</span><span class="p">({</span> <span class="nx">async</span><span class="o">:</span> <span class="kc">true</span> <span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Starting gloss...&#39;</span><span class="p">);</span>

<span class="nx">leipzig</span><span class="p">.</span><span class="nx">gloss</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">elements</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Glossing complete!&#39;</span> <span class="o">+</span> <span class="nx">elements</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Glosser is running...&#39;</span><span class="p">);</span>

<span class="c1">// -&gt; Starting gloss...</span>
<span class="c1">// -&gt; Glosser is running...</span>
<span class="c1">// -&gt; Glossing complete! [object NodeList]</span>
</pre></div>


<p>This callback is especially useful if you're using the asynchronous glosser,
but you can also use it with the synchronous API.</p>
<hr />
<h1><code>Leipzig.abbreviations</code></h1>
<p>Leipzig.js comes with a dictionary of the <a href="https://www.eva.mpg.de/lingua/resources/glossing-rules.php">Standard Leipzig Glossing Rule
abbreviations</a>
baked in. The auto-tagging engine will use these definitions by default when
attempting to assign <code>title</code> attributes to morpheme glosses.</p>
<h2>Modifying the abbreviations</h2>
<p>You can replace this dictionary completely by assigning a new <code>abbreviations</code>
object on your <code>Leipzig()</code> instance:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">leipzig</span> <span class="o">=</span> <span class="nx">Leipzig</span><span class="p">();</span>
<span class="nx">leipzig</span><span class="p">.</span><span class="nx">abbreviations</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">ABBREVIATION</span><span class="o">:</span> <span class="s1">&#39;definition&#39;</span> <span class="p">}</span>
</pre></div>


<p>Or by setting the <code>abbreviations</code> config option when initializing Leipzig:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">newAbbreviations</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">ABBREVIATION</span><span class="o">:</span> <span class="s1">&#39;definition&#39;</span> <span class="p">};</span>
<span class="kd">var</span> <span class="nx">leipzig</span> <span class="o">=</span> <span class="nx">Leipzig</span><span class="p">({</span> <span class="nx">abbreviations</span><span class="o">:</span> <span class="nx">newAbbreviations</span> <span class="p">});</span>
</pre></div>


<p>You can also modify specific entries in the dictionary by setting the relevant
abbreviation to a different value. For example, to change <code>COMP</code> from
<em>complementizer</em> to <em>comparative</em>, you could use the following:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">leipzig</span> <span class="o">=</span> <span class="nx">Leipzig</span><span class="p">();</span>
<span class="nx">leipzig</span><span class="p">.</span><span class="nx">abbreviations</span><span class="p">.</span><span class="nx">COMP</span> <span class="o">=</span> <span class="s1">&#39;comparative&#39;</span><span class="p">;</span>
</pre></div>


<h2>Default Definitions</h2>
<p>The standard list is as follows:</p>
<table>
<thead>
<tr>
<th>Abbreviation</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>first person</td>
</tr>
<tr>
<td>2</td>
<td>second person</td>
</tr>
<tr>
<td>3</td>
<td>third person</td>
</tr>
<tr>
<td>A</td>
<td>agent-like argument of canonical transitive verb</td>
</tr>
<tr>
<td>ABL</td>
<td>ablative</td>
</tr>
<tr>
<td>ABS</td>
<td>absolutive</td>
</tr>
<tr>
<td>ACC</td>
<td>accusative</td>
</tr>
<tr>
<td>ADJ</td>
<td>adjective</td>
</tr>
<tr>
<td>ADV</td>
<td>adverb(ial)</td>
</tr>
<tr>
<td>AGR</td>
<td>agreement</td>
</tr>
<tr>
<td>ALL</td>
<td>allative</td>
</tr>
<tr>
<td>ANTIP</td>
<td>antipassive</td>
</tr>
<tr>
<td>APPL</td>
<td>applicative</td>
</tr>
<tr>
<td>ART</td>
<td>article</td>
</tr>
<tr>
<td>AUX</td>
<td>auxiliary</td>
</tr>
<tr>
<td>BEN</td>
<td>benefactive</td>
</tr>
<tr>
<td>CAUS</td>
<td>causative</td>
</tr>
<tr>
<td>CLF</td>
<td>classifier</td>
</tr>
<tr>
<td>COM</td>
<td>comitative</td>
</tr>
<tr>
<td>COMP</td>
<td>complementizer</td>
</tr>
<tr>
<td>COMPL</td>
<td>completive</td>
</tr>
<tr>
<td>COND</td>
<td>conditional</td>
</tr>
<tr>
<td>COP</td>
<td>copula</td>
</tr>
<tr>
<td>CVB</td>
<td>converb</td>
</tr>
<tr>
<td>DAT</td>
<td>dative</td>
</tr>
<tr>
<td>DECL</td>
<td>declarative</td>
</tr>
<tr>
<td>DEF</td>
<td>definite</td>
</tr>
<tr>
<td>DEM</td>
<td>demonstrative</td>
</tr>
<tr>
<td>DET</td>
<td>determiner</td>
</tr>
<tr>
<td>DIST</td>
<td>distal</td>
</tr>
<tr>
<td>DISTR</td>
<td>distributive</td>
</tr>
<tr>
<td>DU</td>
<td>dual</td>
</tr>
<tr>
<td>DUR</td>
<td>durative</td>
</tr>
<tr>
<td>ERG</td>
<td>ergative</td>
</tr>
<tr>
<td>EXCL</td>
<td>exclusive</td>
</tr>
<tr>
<td>F</td>
<td>feminine</td>
</tr>
<tr>
<td>FOC</td>
<td>focus</td>
</tr>
<tr>
<td>FUT</td>
<td>future</td>
</tr>
<tr>
<td>GEN</td>
<td>genitive</td>
</tr>
<tr>
<td>IMP</td>
<td>imperative</td>
</tr>
<tr>
<td>INCL</td>
<td>inclusive</td>
</tr>
<tr>
<td>IND</td>
<td>indicative</td>
</tr>
<tr>
<td>INDF</td>
<td>indefinite</td>
</tr>
<tr>
<td>INF</td>
<td>infinitive</td>
</tr>
<tr>
<td>INS</td>
<td>instrumental</td>
</tr>
<tr>
<td>INTR</td>
<td>intransitive</td>
</tr>
<tr>
<td>IPFV</td>
<td>imperfective</td>
</tr>
<tr>
<td>IRR</td>
<td>irrealis</td>
</tr>
<tr>
<td>LOC</td>
<td>locative</td>
</tr>
<tr>
<td>M</td>
<td>masculine</td>
</tr>
<tr>
<td>N</td>
<td>neuter</td>
</tr>
<tr>
<td>NEG</td>
<td>negation / negative</td>
</tr>
<tr>
<td>NMLZ</td>
<td>nominalizer / nominalization</td>
</tr>
<tr>
<td>NOM</td>
<td>nominative</td>
</tr>
<tr>
<td>OBJ</td>
<td>object</td>
</tr>
<tr>
<td>OBL</td>
<td>oblique</td>
</tr>
<tr>
<td>P</td>
<td>patient-like argument of canonical transitive verb</td>
</tr>
<tr>
<td>PASS</td>
<td>passive</td>
</tr>
<tr>
<td>PFV</td>
<td>perfective</td>
</tr>
<tr>
<td>PL</td>
<td>plural</td>
</tr>
<tr>
<td>POSS</td>
<td>possessive</td>
</tr>
<tr>
<td>PRED</td>
<td>predicative</td>
</tr>
<tr>
<td>PRF</td>
<td>perfect</td>
</tr>
<tr>
<td>PRS</td>
<td>present</td>
</tr>
<tr>
<td>PROG</td>
<td>progressive</td>
</tr>
<tr>
<td>PROH</td>
<td>prohibitive</td>
</tr>
<tr>
<td>PROX</td>
<td>proximal / proximate</td>
</tr>
<tr>
<td>PST</td>
<td>past</td>
</tr>
<tr>
<td>PTCP</td>
<td>participle</td>
</tr>
<tr>
<td>PURP</td>
<td>purposive</td>
</tr>
<tr>
<td>Q</td>
<td>question particle / marker</td>
</tr>
<tr>
<td>QUOT</td>
<td>quotative</td>
</tr>
<tr>
<td>RECP</td>
<td>reciprocal</td>
</tr>
<tr>
<td>REFL</td>
<td>reflexive</td>
</tr>
<tr>
<td>REL</td>
<td>relative</td>
</tr>
<tr>
<td>RES</td>
<td>resultative</td>
</tr>
<tr>
<td>S</td>
<td>single argument of canonical intransitive verb</td>
</tr>
<tr>
<td>SBJ</td>
<td>subject</td>
</tr>
<tr>
<td>SBJV</td>
<td>subjunctive</td>
</tr>
<tr>
<td>SG</td>
<td>singular</td>
</tr>
<tr>
<td>TOP</td>
<td>topic</td>
</tr>
<tr>
<td>TR</td>
<td>transitive</td>
</tr>
<tr>
<td>VOC</td>
<td>vocative</td>
</tr>
</tbody>
</table>

    <footer id="page-footer">
      <p>&copy; 2015 Benjamin Chauvette</p>
      <p>Leipzig.js is licensed under the <a href="https://raw.githubusercontent.com/bdchauvette/leipzig.js/master/LICENSE">ISC License</a>.
      <p>Leipzig.js is not affiliated with the <a href="http://www.zv.uni-leipzig.de/">University of Leipzig</a>, nor with the authors of the <a href="https://www.eva.mpg.de/lingua/resources/glossing-rules.php">Leipzig Glossing Rules</a>.</p>
      <p><a href="#">Back to Top &uarr;</a></p>
    </footer>
  </div>

    <script src="//cdn.jsdelivr.net/leipzig/latest/leipzig.min.js"></script>

  <script src="/leipzig.js/theme/js/documentation.js"></script>
</body>
</html>